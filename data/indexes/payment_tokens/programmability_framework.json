{
  "title": "A Framework for Programmability in Digital Currency Systems",
  "description": "This MIT DCI paper presents a systematic framework for understanding and designing programmability in digital currency systems — the ability to attach executable logic (smart contracts, conditional payments, compliance rules) to digital money. The paper distinguishes between three levels of programmability: (1) Transaction-level — conditions on individual payments (timelocks, multisig, hash locks), (2) Asset-level — rules embedded in the currency itself (holding limits, transfer restrictions, automatic tax withholding), and (3) System-level — programmable monetary policy and infrastructure (interest rate adjustment, reserve management, cross-system interoperability). For each level, the paper analyzes design choices, trade-offs (privacy vs. compliance, flexibility vs. safety), and implementation approaches across different technical architectures (UTXO vs. account-based, on-chain vs. off-chain execution). The framework is intended to help central banks, regulators, and system designers make informed decisions about what programmability features to include in CBDCs, stablecoins, and tokenized deposits.",
  "nodes": [
    {
      "node_id": "1",
      "title": "Defining Programmability: Three Levels",
      "summary": "Establishes a taxonomy of programmability in digital currency. Level 1 (Transaction-level): conditions on individual transactions — who can spend, when, under what circumstances. Examples: timelocks (can't spend before date X), multisig (requires N-of-M signatures), hash locks (reveal a secret to claim). Bitcoin Script and Lightning Network HTLCs operate at this level. Level 2 (Asset-level): rules embedded in the currency token itself that govern all transfers — transfer limits, KYC requirements, blacklists, automatic fee deductions. ERC-20 tokens with transfer hooks and CBDC holding limits operate at this level. Level 3 (System-level): programmable monetary infrastructure — automated interest distribution, dynamic reserve requirements, cross-ledger atomic operations. This is the most powerful and least explored level.",
      "start_page": 1,
      "end_page": 4,
      "content": "Programmability taxonomy: Level 1 — Transaction-level programmability: Rules attached to specific transactions or outputs. The most constrained and safest form. Examples: (a) Timelocks — funds cannot be spent before a specific time or block height. Used in Lightning Network channels for dispute resolution. (b) Multisignature — transaction requires signatures from multiple parties (e.g., 2-of-3 signers for corporate treasury). (c) Hash Time-Locked Contracts (HTLCs) — conditional payment based on revealing a cryptographic preimage. Enables atomic cross-chain swaps and payment channel routing. (d) Escrow — funds released upon satisfaction of verifiable conditions. Design considerations: Limited expressiveness (can't implement arbitrary logic), but high safety (bounded behavior, formal verification possible). Level 2 — Asset-level programmability: Rules embedded in the token that apply to all transfers of that asset. Examples: (a) Transfer restrictions — asset can only be transferred to KYC-verified addresses. (b) Holding limits — no address may hold more than X units (relevant for CBDC). (c) Automatic compliance — every transfer checks against a sanctions list. (d) Fee extraction — automatic tax withholding or transaction fee deduction. Design considerations: More expressive but harder to verify safety. Rules apply universally, so bugs affect all holders. Level 3 — System-level programmability: Programmable monetary infrastructure. Examples: (a) Automated interest — CBDC balances automatically earn/pay interest based on policy rate. (b) Dynamic policy — reserve requirements, holding limits, or fees adjust automatically based on macroeconomic conditions. (c) Cross-system interoperability — atomic operations spanning multiple ledgers or currencies.",
      "nodes": []
    },
    {
      "node_id": "2",
      "title": "Design Trade-offs in Programmable Money",
      "summary": "Analyzes the fundamental trade-offs that digital currency designers face when adding programmability. Privacy vs. Compliance: more programmable rules require more information visibility, reducing privacy. Flexibility vs. Safety: more expressive programming languages enable more use cases but create larger attack surfaces (reentrancy, overflow, denial-of-service). On-chain vs. Off-chain execution: on-chain execution is transparent and verifiable but expensive and public; off-chain execution is private and efficient but requires trust assumptions or complex cryptography (ZKPs). Centralized vs. Decentralized governance: who decides what programs can run, and who can update them?",
      "start_page": 4,
      "end_page": 8,
      "content": "Design trade-offs framework: (1) Privacy vs. Compliance — compliance programmability (AML checks, sanctions screening, tax reporting) requires visibility into transaction details. Privacy programmability (confidential amounts, anonymous transfers) hides those details. Resolving this tension requires selective disclosure or zero-knowledge proofs, which add complexity. Design spectrum: fully transparent (all rules verifiable, no privacy) → selective disclosure (rules verified without revealing data) → fully private (no compliance visibility). (2) Flexibility vs. Safety — programming language expressiveness determines what programs can be written. Bitcoin Script: intentionally limited (no loops, no state), very safe, but can't implement complex logic. Solidity (Ethereum): Turing-complete, highly flexible, but has produced billions in losses from bugs (reentrancy attacks, overflow, access control failures). Move (Sui/Aptos): resource-oriented, prevents certain bug classes by design, moderate flexibility. Design choice: more flexibility = more use cases but more attack surface. (3) On-chain vs. Off-chain execution — On-chain: every validator executes every program. Advantages: transparent, verifiable, censorship-resistant. Disadvantages: expensive (gas fees), slow (consensus latency), public (privacy loss). Off-chain: programs execute between parties, only results are settled on-chain. Advantages: private, fast, cheap. Disadvantages: requires either trust between parties or ZKP verification, which is computationally expensive. Hybrid: PArSEC-style state channels — off-chain execution with on-chain dispute resolution. (4) Governance — who controls the programs? Immutable contracts (no one can change after deployment) are safe but inflexible. Upgradeable contracts allow bug fixes but introduce governance risk (who authorizes upgrades?).",
      "nodes": []
    },
    {
      "node_id": "3",
      "title": "Programmability in CBDC Design",
      "summary": "Applies the framework specifically to CBDC design decisions. Central banks face unique programmability considerations: they must balance innovation with monetary sovereignty, privacy with law enforcement, and programmability with simplicity. The paper analyzes several CBDC programmability use cases: (1) Purpose-bound money — government transfers that can only be spent on approved categories (food assistance, housing subsidies). (2) Expiring money — stimulus payments with expiration dates to encourage spending. (3) Automated compliance — built-in AML/CFT that operates without central surveillance. (4) Interest-bearing digital currency — programmable interest rates as a monetary policy tool. For each, the paper assesses technical feasibility, privacy implications, and potential for government overreach.",
      "start_page": 8,
      "end_page": 12,
      "content": "CBDC programmability analysis: (1) Purpose-bound money — restricting CBDC spending to approved merchant categories (e.g., food assistance funds that can only be spent at grocery stores). Technical implementation: token-level metadata specifying allowed merchant category codes, verified at transaction validation. Privacy concern: every transaction reveals both amount and merchant category, enabling detailed spending surveillance. The paper argues purpose restrictions should be implemented at the intermediary level (bank app restricts purchases) rather than the protocol level (CBDC itself restricts), preserving fungibility and privacy. (2) Expiring money — CBDC that loses value or becomes unspendable after a deadline, incentivizing rapid spending during economic downturns. Technical implementation: timelock that returns expired funds to the treasury. Economic analysis: effective stimulus tool but creates perverse incentives (rush spending on non-essential goods before deadline). Precedent: Wörgl experiment (1932), China's digital yuan trial coupons. (3) Automated compliance — every CBDC transaction automatically checked against sanctions lists, transaction limits, and reporting thresholds without central authority seeing individual transactions. Technical implementation: zero-knowledge proofs (following zkLedger approach) proving compliance properties without revealing transaction details. This is the most promising and technically challenging use case. (4) Programmable interest — CBDC balances automatically earn/pay interest at the policy rate, creating a direct monetary policy transmission channel. Technical implementation: balance adjustment at epoch boundaries (daily/weekly). Implications: powerful monetary policy tool but could disintermediate banks (why deposit at a bank if CBDC earns risk-free interest directly from the central bank?).",
      "nodes": []
    },
    {
      "node_id": "4",
      "title": "Implementation Architectures and Recommendations",
      "summary": "Compares implementation architectures for programmable digital currency and provides recommendations. Analyzes three architectural approaches: (1) UTXO with script (Bitcoin-style) — suitable for Level 1 programmability, limited but safe. (2) Account-based with VM (Ethereum-style) — suitable for all levels, flexible but complex. (3) Hybrid — UTXO for the base layer with optional smart contract execution via state channels or ZKP. Recommends that CBDCs adopt a layered approach: minimal Level 1 programmability at the base layer (timelocks, multisig), Level 2 programmability through authorized smart contract modules (not arbitrary user code), and Level 3 programmability through central bank governance interfaces.",
      "start_page": 12,
      "end_page": 16,
      "content": "Architecture comparison and recommendations: (1) UTXO + Script (Bitcoin model) — Pros: simple, formally verifiable, no reentrancy or state-consistency issues, natural privacy (no account balances). Cons: limited expressiveness, no persistent state, complex multi-step protocols. Best for: Level 1 programmability (conditional payments, timelocks, multisig). Used by: Bitcoin, OpenCBDC/Hamilton. (2) Account + VM (Ethereum model) — Pros: Turing-complete, persistent state, composable contracts, rich ecosystem. Cons: complex security model (reentrancy, front-running, gas estimation), global state creates bottlenecks, all contract state is public. Best for: Level 2-3 programmability when privacy is not critical. Used by: Ethereum, various permissioned blockchains. (3) Hybrid (Recommended for CBDCs) — Base layer: UTXO model for core payments (fast, private, simple). Extension layer: authorized smart contract modules for specific use cases (escrow, compliance, DvP). These modules are pre-audited and approved by the central bank, not arbitrary user code. Off-chain layer: state channels (PArSEC) for confidential programmable execution. Governance layer: central bank interfaces for monetary policy parameters (interest rates, holding limits, authorized intermediaries). Recommendations: (a) Start simple — launch with Level 1 programmability only. Add complexity incrementally as use cases are validated. (b) Authorize, don't open — unlike Ethereum, a CBDC should not allow arbitrary contract deployment. Pre-approved, audited contract templates reduce attack surface. (c) Separate concerns — programmability for compliance (mandatory, system-level) should be distinct from programmability for innovation (optional, application-level). (d) Privacy by default — programmability should not require transaction transparency. Use ZKP-based approaches where possible.",
      "nodes": []
    }
  ],
  "_metadata": {
    "source_file": "programmability_framework.pdf",
    "total_pages": 16,
    "source_path": "",
    "authors": ["MIT DCI"],
    "venue": "arXiv:2311.04874",
    "year": 2023
  }
}
